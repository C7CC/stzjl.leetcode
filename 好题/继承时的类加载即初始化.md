## 继承时的类加载即初始化

###### 构造器是在创建对象时调用，类加载时不用构造器

1，子类继承了父类的所有属性和方法，非私有的属性和方法可以在子类中可直接访问

2，子类进行类加载时会先进行父类的类加载

3，创建子类对象时，会通过子类构造器中的super()来**先调用父类的构造器*****完成***父类的初始化

4，super()，this()均只能放在构造器首行故不能同时存在（this()表示调用子类都其它构造器，this的其它作用还是可以使用的）

> #### 加载
>
> 1，父类加载，静态变量和静态代码块初始化
>
> 2，子类加载，静态变量和静态代码块初始化
>
> ###### 创建子类对象
>
> 3，父类的普通代码块和普通成员变量初始化
>
> 4，子类的普通代码块和普通成员变量初始化
>
> ### 注意
>
> ###### 静态方法和普通方法均在类加载时进行加载而不是创建对象时
>
> ###### 创建子类对象会导致父类初始化但堆中不会有父类的实例对象（对象不等于实例对象）
>
> 父类变量和子类变量均会在子类的对象的堆空间中进行初始化（此处初始化表示对象初始化而不是类加载时的初始化）
>

### 会造成类加载

1，new 对象实例，调用了该类的静态属性或方法

2，要执行的主类即包含mian()的类

3，子类加载会使父类先进行加载

4，反射时加载类

5，特殊情况

### 不会造成类加载（被动引用）

1，子类调用父类中的静态属性或方法

2，子类final static修饰属性底层优化不用类加载就可以调用

3，通过数组定义来引用类

SuperClass_	[]	Class_ = new SuoerClass_[];
